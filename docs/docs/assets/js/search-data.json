{"0": {
    "doc": "Getting Started",
    "title": "Quick start",
    "content": "Hello World . Create a file called bricks/hello-world.html: . &lt;template&gt; &lt;p&gt;Hello ${state.name}&lt;/p&gt; &lt;/template&gt; &lt;script&gt; export default class extends Lego { init() { this.state = { name: \"World!\" } } } &lt;/script&gt; . Compile with npx lego bricks . And use it in your index.html . &lt;script src=\"./dist/index.js\" type=\"module\"&gt;&lt;/script&gt; &lt;hello-world /&gt; . Run a local web server (ie: python3 -m http.server) and display your index.html (ie: http://localhost:8000). What did just happen? . Here‚Äôs what you just did with this simple code: . | you created a native HTML element called hello-world | you made it react with a name state property | you imported all components from ./dist/index.js (only 1 for now) | you instanciated the HTML element &lt;hello-world /&gt; | . ",
    "url": "/getting-started/#quick-start",
    "relUrl": "/getting-started/#quick-start"
  },"1": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": "Lego requires npm and node. Then install the compiler with npm i @polight/lego . ",
    "url": "/getting-started/",
    "relUrl": "/getting-started/"
  },"2": {
    "doc": "Getting deep",
    "title": "Getting deep",
    "content": "Native web-components . Because Lego is actual native web-components, all its native possibilities (like slots), :host and whatever exists or will exist are on board. Browser compatibility . Lego is based on native customElements. Support for customElement is spreading and shall increase in time. When building a web-app you may have control of the browsers. If you‚Äôre building a more general website you may need to increase the overall browser compatibility and install the custom-element polyfill. Dependencies . It is still fully compatible with native custom elements. No magic behind the scene, no complexity, just a couple of useful methods to write native web-components easier. Using a compiled component has no dependency, nothing extra injected in the browser. Compiling depends on jsdom. ",
    "url": "/advanced-webcomponents/",
    "relUrl": "/advanced-webcomponents/"
  },"3": {
    "doc": "Usage",
    "title": "Usage of Lego web-components",
    "content": "A web-component can optionally have 3 parts: some HTML in a &lt;template&gt; tag, some JavaScript in a &lt;script&gt; tag and some CSS in a &lt;style&gt; tag. You can make a web-component for muliple reasons. If you just want to re-use a piece of HTML, the &lt;template&gt; tag is all you need. If you want to polish it‚Äôs look üíÖ, &lt;style&gt; is your friend. Bonus: it‚Äôs fully scoped with no leaking out of context. When some user interaction or reactiveness is demanded, &lt;script&gt; is going to be the guy. ",
    "url": "/usage-web-components/#usage-of-lego-web-components",
    "relUrl": "/usage-web-components/#usage-of-lego-web-components"
  },"4": {
    "doc": "Usage",
    "title": "Usage",
    "content": ". | Usage of Lego web-components | . ",
    "url": "/usage-web-components/",
    "relUrl": "/usage-web-components/"
  },"5": {
    "doc": "Template tag",
    "title": "Template tag",
    "content": "&lt;template&gt; tag . An HTML content is written within a &lt;template&gt; tag. It‚Äôs just basic HTML augmented with a little of superpowers ü¶∏. Let‚Äôs call these superpowers ‚Äúdirectives‚Äù. You may easily detect them as they are prefixed with : or @. Only 4 directives to know: . | :if to display a tag based on a condition | :for to repeat a tag | : to evaluate a string | @ to bind an event | . Note that :if and :for attributes, when used in the same tag should be used with an order in mind: &lt;a :if=\"user\" :for=\"user in state.users\"&gt; won‚Äôt work, but &lt;a :if=\"state.users.length\" :for=\"user in state.users\"&gt; will first evaluate if the users array has items, or &lt;a :for=\"user in users\" :if=\"user\"&gt; will check that each individual user has a value. &lt;a :if=\"state.isAdmin\" :for=\"user in state.users\"&gt; won‚Äôt loop at all if isAdmin is false. ",
    "url": "/usage-web-components/template/",
    "relUrl": "/usage-web-components/template/"
  },"6": {
    "doc": "Condition :if",
    "title": "Condition :if",
    "content": ":if Directive . Conditionally display a tag and its descendants. Example: &lt;p :if=\"state.count &lt; 5\"&gt;Less than 5&lt;/p&gt; will be displayed if the condition is met. ",
    "url": "/usage-web-components/condition/",
    "relUrl": "/usage-web-components/condition/"
  },"7": {
    "doc": "Loop :for",
    "title": "Loop :for",
    "content": ":for Directive . Repeat a tag based on a property. The syntax is as follow: :for=\"item in state.items\". The item value will be available trough ${item} within the loop. If you need an incremental index i, use :for=\"item, i in state.items\". Example: &lt;li :for=\"attendee in state.attendees\"&gt;${attendee}&lt;/li&gt; with a state as this.state = { attendees: ['John', 'Mary'] } will display &lt;li&gt;John&lt;/li&gt;&lt;li&gt;Mary&lt;/li&gt; . ",
    "url": "/usage-web-components/loop/",
    "relUrl": "/usage-web-components/loop/"
  },"8": {
    "doc": "Custom directives",
    "title": "Custom directives",
    "content": ": Custom Directive . A custom directive will interpret in JS whatever you pass as value. &lt;template&gt; &lt;a :href=\"this.getUrl('144')\"&gt;Visit Profile&lt;/a&gt; &lt;/template&gt; &lt;script&gt; export default class extends Lego { getUrl(id) { return `/user/${id}` } } &lt;/script&gt; . outputs . &lt;a href=\"/user/144\"&gt;Visit Profile&lt;/a&gt; . Boolean attributes . Example: &lt;input type=checkbox :checked=\"state.agreed\" :required=\"state.mustAgree\"&gt;. With the following state: this.state = { agreed: false, mustAgree: true } would render &lt;input type=checkbox required=\"required\"&gt;. ",
    "url": "/usage-web-components/custom-directive/",
    "relUrl": "/usage-web-components/custom-directive/"
  },"9": {
    "doc": "Binding events",
    "title": "Binding events",
    "content": "@ Directive for binding Events . &lt;template&gt; &lt;button @click=\"sayHi\" name=\"the button\"&gt;click&lt;/button&gt; &lt;script&gt; export default class extends Lego { sayHi(event) { alert(`You clicked to says hi! üëãüèº`) } } &lt;/script&gt; . ",
    "url": "/usage-web-components/events/",
    "relUrl": "/usage-web-components/events/"
  },"10": {
    "doc": "Reactive properties",
    "title": "Reactive properties",
    "content": "Reactive Properties . The state is where the reactiveness takes place. declare a state object in the init() function with default values: . init() { this.state = { user: { firstname: 'John', lastname: 'Doe' }, status: \"Happy üòÑ\" } } . Displaying a state value is as simple as writing ${state.theValue} in your HTML. When you need your component to react, call the this.render() method with your updated state: . itemSelected(event) { this.render({ selected: \"apple\", isAdmin: true }) } . This will refresh your component where needed. When state is just mutated, the changed(changedProps) is called. This changed() method is called before (re-)rendering. ",
    "url": "/usage-web-components/reactive/",
    "relUrl": "/usage-web-components/reactive/"
  },"11": {
    "doc": "Pass attributes",
    "title": "&lt;script&gt; tag",
    "content": "The script tag is has a special behavior. You will create a class extending the component, that‚Äôs how you build your full component with advanced script. To do so extend the _, that‚Äôs a naming convention: . export default class extends Lego { ‚Ä¶ } . ",
    "url": "/usage-web-components/attributes/#script-tag",
    "relUrl": "/usage-web-components/attributes/#script-tag"
  },"12": {
    "doc": "Pass attributes",
    "title": "Pass attributes",
    "content": "Component Attributes . Attributes declared on the components will be all be accessible through the state. If the property is initialized in the this.state, the attribute will be reactive: . &lt;x-user status=\"thinking ü§î\"&gt;&lt;x-user&gt; . status will therefore be reactive and the thinking ü§î attribute value will overwrite the Happy üòÑ default status. ‚ö†Ô∏è A property that is not declared in the state won‚Äôt be reactive. These properties can be accessed through this.getAttribute() from within the component. After all, these components are just native! üè° . Slots . Slots are part of the native web-component. Because Lego builds native web-components, you can use the standard slots as documented. Example: . index.html . &lt;user-profile&gt; &lt;span&gt;This user is in Paris&lt;/span&gt; &lt;user-profile&gt; . bricks/user-profile.html . &lt;template&gt; &lt;h1&gt;User profile&lt;/h1&gt; &lt;p&gt;important information: &lt;slot&gt;&lt;/slot&gt;&lt;/p&gt; &lt;/template&gt; . Will write ‚Ä¶&lt;p&gt;important information: &lt;span&gt;This user is in Paris&lt;/span&gt;&lt;/p&gt; . See more advanced examples. Reactive CSS &lt;style&gt; . CSS is much more fun when it‚Äôs scoped. Here it come with the web-components. Here again, no trick, just the full power of web-components and scoping styles. Well, you should know that the css is reactive too! üò≤ . Writing CSS is as easy as . &lt;template&gt; &lt;h1&gt;Bonjour!&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default class extends Lego { init() { this.state = { fontScale: 1 } } } &lt;/script&gt; &lt;style&gt; :host { font-size: ${state.fontScale}rem; } h1 { padding: 1rem; text-align: center; } &lt;/style&gt; . Host . :host is a native selector for web-components. It allows to select the current component itself. Variables . You can use variables in your CSS just like in your templates. Example: . &lt;template&gt; &lt;h1&gt;Bonjour&lt;h1&gt; &lt;/template&gt; &lt;script&gt; export default class extends Lego { init() { this.state = { color: '#357' } } } &lt;/script&gt; &lt;style&gt; h1 { color: ${ state.color }; } &lt;/style&gt; . will apply the #357 color onto h1. ",
    "url": "/usage-web-components/attributes/",
    "relUrl": "/usage-web-components/attributes/"
  },"13": {
    "doc": "Using slots",
    "title": "Using slots",
    "content": "Slots . Slots are part of the native web-component. Because Lego builds native web-components, you can use the standard slots as documented. Example: . index.html . &lt;user-profile&gt; &lt;span&gt;This user is in Paris&lt;/span&gt; &lt;user-profile&gt; . bricks/user-profile.html . &lt;template&gt; &lt;h1&gt;User profile&lt;/h1&gt; &lt;p&gt;important information: &lt;slot&gt;&lt;/slot&gt;&lt;/p&gt; &lt;/template&gt; . Will write ‚Ä¶&lt;p&gt;important information: &lt;span&gt;This user is in Paris&lt;/span&gt;&lt;/p&gt; . See more advanced examples. ",
    "url": "/usage-web-components/slots/",
    "relUrl": "/usage-web-components/slots/"
  },"14": {
    "doc": "Reactive CSS",
    "title": "Reactive CSS",
    "content": "Reactive CSS &lt;style&gt; . CSS is much more fun when it‚Äôs scoped. Here it come with the web-components. Here again, no trick, just the full power of web-components and scoping styles. Well, you should know that the css is reactive too! üò≤ . Writing CSS is as easy as . &lt;template&gt; &lt;h1&gt;Bonjour!&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default class extends Lego { init() { this.state = { fontScale: 1 } } } &lt;/script&gt; &lt;style&gt; :host { font-size: ${state.fontScale}rem; } h1 { padding: 1rem; text-align: center; } &lt;/style&gt; . Host . :host is a native selector for web-components. It allows to select the current component itself. Variables . You can use variables in your CSS just like in your templates. Example: . &lt;template&gt; &lt;h1&gt;Bonjour&lt;h1&gt; &lt;/template&gt; &lt;script&gt; export default class extends Lego { init() { this.state = { color: '#357' } } } &lt;/script&gt; &lt;style&gt; h1 { color: ${ state.color }; } &lt;/style&gt; . will apply the #357 color onto h1. ",
    "url": "/usage-web-components/reactive-css/",
    "relUrl": "/usage-web-components/reactive-css/"
  },"15": {
    "doc": "Script Tag",
    "title": "&lt;script&gt; tag",
    "content": "The script tag is has a special behavior. You will create a class extending the component, that‚Äôs how you build your full component with advanced script. To do so extend the _, that‚Äôs a naming convention: . export default class extends Lego { ‚Ä¶ } . ",
    "url": "/usage-web-components/script-tag/#script-tag",
    "relUrl": "/usage-web-components/script-tag/#script-tag"
  },"16": {
    "doc": "Script Tag",
    "title": "Script Tag",
    "content": " ",
    "url": "/usage-web-components/script-tag/",
    "relUrl": "/usage-web-components/script-tag/"
  },"17": {
    "doc": "Naming web-components",
    "title": "Naming web-components",
    "content": "The name of the file will be the name of the component. Example: components/x-button.html will create &lt;x-button&gt; component. However in some cases you may want to give your component a different name than the file. To do so, you should give a name attribute in your &lt;template&gt; tag. Example: . components/x-button.html: . &lt;template name=\"my-super-button\"&gt;&lt;/template&gt; . Will make &lt;my-super-button&gt; component available. Note that because it builds native web-components, the naming convention must respect the ones from the standards (lowercase, with a dash in the name, starting with a letter, ‚Ä¶) . ",
    "url": "/naming-components/",
    "relUrl": "/naming-components/"
  },"18": {
    "doc": "Advanced Web-Components",
    "title": "Advanced Web-Components",
    "content": "Let‚Äôs write a web-component that: . | displays the full name of a user | shows a welcome text and the user | list all user‚Äôs favorite fruit | toggles user registration | . bricks/user-profile.html . &lt;template&gt; &lt;div&gt; &lt;h1&gt;${state.firstName} ${state.lastName}'s profile&lt;/h1&gt; &lt;p&gt;Welcome ${state.firstName}!&lt;/p&gt; &lt;section :if=\"state.fruits.length\"&gt; &lt;h3&gt;You favorite fruits:&lt;/h3&gt; &lt;ul&gt; &lt;li :for=\"fruit in state.fruits\"&gt;${fruit.name} ${fruit.icon}&lt;/li&gt; &lt;/ul&gt; &lt;/section&gt; &lt;p :if=\"state.registered\"&gt;You are registered!&lt;/p&gt; &lt;button @click=\"edit\"&gt;Edit my profile&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default class extends Lego { init() { this.state = { registered: false, firstName: 'John', lastName: 'Doe', fruits: [{ name: 'Apple', icon: 'üçé' }, { name: 'Pineapple', icon: 'üçç' }] } } register() { this.render({ registered: confirm('You are about to register‚Ä¶') }) } } &lt;/script&gt; . Compile this component: npx lego bricks . Then include it in your page: . index.html . &lt;user-profile&gt;&lt;/user-profile&gt; &lt;script src=\"./dist/index.js\" type=\"module\"&gt;&lt;/script&gt; . Run your webserver and see your little app! . When developing you may want to automatically watch files changes. In that case pass the -w flag: npx lego -w bricks . Tip: you probably want to store this task with a shortcut like npm run watch. To do so just add \"watch\": \"lego -w bricks\" in you package.json scripts. ",
    "url": "/advanced-components/",
    "relUrl": "/advanced-components/"
  },"19": {
    "doc": "Compiling",
    "title": "Compiling",
    "content": "Compiling Lego component is built-in with no extra installation; pretty straighforward. LEGO_URL=&lt;/url/to/lego.min.js&gt; npx lego &lt;source_path&gt; &lt;target_file_path&gt; . Would compile the source_path file or folder (recursively) into target_file_path js file using lego.min.js from the declared url. As mentioned before, when developing you probably want to watch for changes with the -w option: npx lego -w &lt;source_path&gt; &lt;target_file_path&gt; . source_path: either a file or a directory (relative or absolute). If it‚Äôs a directory, it will recursively read all the .html files and compile them into the target_file. target_file_path: (default: components.js) the path (relative or absolute) to a .js file. That file will be created and contain all the components. ",
    "url": "/compile-components/",
    "relUrl": "/compile-components/"
  },"20": {
    "doc": "Testing",
    "title": "Running tests ",
    "content": "Just install node dev dependencies (npm install) and run the tests (npm test). ",
    "url": "/testing-components/#running-tests-",
    "relUrl": "/testing-components/#running-tests-"
  },"21": {
    "doc": "Testing",
    "title": "Testing",
    "content": " ",
    "url": "/testing-components/",
    "relUrl": "/testing-components/"
  }
}
